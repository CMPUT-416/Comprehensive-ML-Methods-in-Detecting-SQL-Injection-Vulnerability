import sys
import nltk
nltk.download('punkt')

from prettytable import PrettyTable
from gensim.models import Doc2Vec

from preprocessor import Preprocessor
from models.knn import KNNModel
from models.nb import NBModel
from models.logReg import LogRegModel
from models.svm import SVMModel
from models.dt import DTModel
from models.gbdt import GBDTModel


# Global Variable Settings
SELECTIONS = {
    1: "Logistic Regression",
    2: "Naive Bayes",
    3: "k-nearest Neighbor",
    4: "Support Vector Machine",
    5: "Decision Tree",
    6: "Gradient Boost Decision Tree"
}
CV = 3
EVAL = ('neg_mean_squared_error', 'f1_macro', 'balanced_accuracy')


# Color Highlight Settings
B = "\033[0;34;40m"     # BLUE
Y = "\033[0;33;40m"     # YELLOW
G = "\033[0;32;40m"     # GREEN
R = "\033[0;31;40m"     # RED
RESET = "\033[0m"       # COLOR RESET


class Interactor:
    def __init__(self):
        """
            Initializes the interactor with an SVM model and a pre-trained embedding;
        """
        # Load the default setting to start
        print("\n>> Initializing detector...")
        self.SELECT = 4
        self.detector = SVMModel(cv=CV, cvEval=EVAL)
        self.detector._reload()
        self.embedder = Doc2Vec.load("srcs/doc2vec.pkl")
        print(">> DONE.\n")

    def help(self, init=False):
        """
            This method is used to print out the help instructions and introduce the functions of the detector;
        """
        # Outputs indication information
        if init:
            print(">> Hi, this detector applies multiple ML models to check risks of SQL semantic inputs, you could")
        print(Y + "* Enter <(r)ebuild> to rebuild a model from scratch (cover the pre-trained)")
        print("* Enter <(d)etect> to check a SQL input by a specific pretrained detector")
        print("* Enter <(s)can> to scan a SQL input with all pretrained detectors")
        print("* Enter <(f)ile> to scan a log file with all pretrained detectors")
        print("* Enter <(a)nalyze> (developer function) to process the ground-truth comparison with a log")
        print("* Enter <(h)elp> to review the instruction page")
        print("* Enter <(e)xit> to exit")
        print(RESET)

    def detect(self):
        """
            This method is used to detect the  SQL injection vulnerability in an input text by selecting a specific
        pretrained detector;
        """
        # Ask for a model selection
        self.select()

        # Outputs indication information to ask for an input of SQL semantics
        print(">> Enter your SQL semantics to test")
        sql = input("> ")
        # Preprocess the input and the call the .simpleDetect() to detect it
        sql_tokens = nltk.word_tokenize(sql.strip())
        sql_vector = self.embedder.infer_vector(sql_tokens)
        outcome = self.detector.simpleDetect(sql_vector)

        # Outputs indication information about the detection outcomes about the risk detected
        if outcome[0] == 0:
            risk = "HIGH SQL INJECTION RISK"
        else:
            risk = "LOW SQL INJECTION RISK"
        print(f"\n>> Detection result: {risk} \n(predicted by Model {self.SELECT} - {SELECTIONS[self.SELECT]})\n")

    def select(self):
        """
            This method is used to select a specific classification model for detecting the SQL injection vulnerability;
        """
        # Outputs indication information
        print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
        print(">> Enter an ID to change detector, you may have"
              "\n\t* 1=LogisticRegression;"
              "\n\t* 2=Naive Bayes;"
              "\n\t* 3=k-nearest Neighbors;"
              "\n\t* 4=Support Vector Machine;"
              "\n\t* 5=Decision Tree;"
              "\n\t* 6=Gradient Boost Decision Tree;")
        try:
            # Outputs indication information to ask for a specific selection of classification models
            self.SELECT = int(input("> "))
            if self.SELECT == 0:
                pass
            elif self.SELECT == 1:
                self.detector = LogRegModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 2:
                self.detector = NBModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 3:
                self.detector = KNNModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 4:
                self.detector = SVMModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 5:
                self.detector = DTModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 6:
                self.detector = GBDTModel(cv=CV, cvEval=EVAL)
            else:
                raise
        except:
            # If the input is invalid, then report the issue and redo a selection
            sys.stderr.write("\n>> ModelSelectionError: Invalid model selection.")
            self.select()
            return
        # Reload the model depends on the user selection and give feedback
        self.detector._reload()
        print(">> Model reload successfully")

    def rebuild(self):
        """
            This method is used to rebuild a specific machine learning model based on the demand from training;
        """
        while True:
            # Output indication information to confirm the rebuilding demand
            print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
            IN = input(">> Do you want to rebuild it? [(y)es for rebuilding] [(s)elect for switching model] \n> ").strip().lower()
            if IN == "yes" or IN == "y":
                print(f"* WARNING: This operation will cover the existing pre-training one;")
                IN2 = input(f">> Are you sure you want to rebuild Model {self.SELECT} - {SELECTIONS[self.SELECT]}? [(y)es to continue] [(n)o to cancel] \n> ")
                if IN2 == 'no' or IN2 == "n":
                    break

                # Start the rebuilder, first take data reprocess and then retrain a specific model on it
                print(f"\n>> Data Preprocessor Ready.")
                P = Preprocessor(dirPath="data/")
                P.process()
                print(f"\n>> Model Trainer Ready.")
                if self.SELECT == 1:
                    self.detector = LogRegModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 2:
                    self.detector = NBModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 3:
                    self.detector = KNNModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 4:
                    self.detector = SVMModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 5:
                    self.detector = DTModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 6:
                    self.detector = GBDTModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)

                # Output indication information to show the rebuilding result
                print(f"\n>> Model Rebuilt Successfully.")
                print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
                break

            # Switch to other model selection if required
            elif IN == "select" or IN == "s":
                self.select()
            # For any other invalid input, stop the rebuilding process
            else:
                break

    def scan(self, sql=None, info=False):
        """
            This method is used to scan an input with all pre-trained detectors and provides a weighted risk assessment;
        :param
            - sql, str, an input SQL semantics waiting for scanning;
            - info, bool, provides indication for the message printing;
        :return
            - (meanEval, risk), tuple, the scanning outcomes about the risk index and the risk extent;
        """
        # Prepare all classifier and the corresponding weights to process the all-around detection
        detectors = [LogRegModel(cv=CV, cvEval=EVAL),
                     NBModel(cv=CV, cvEval=EVAL),
                     KNNModel(cv=CV, cvEval=EVAL),
                     SVMModel(cv=CV, cvEval=EVAL),
                     DTModel(cv=CV, cvEval=EVAL),
                     GBDTModel(cv=CV, cvEval=EVAL)]
        # Weights determined by the second-level machine learning model
        #   (executes `reweight1.py` based on predictions saved in `Proj/weights`, see `README.md` for more details)

        # 2nd-level ML Determination of Weights:
        """ XGBOOST """
        weights = [1.2215568862275448,
                   1.1137724550898203,
                   0.3592814371257485,
                   0.8622754491017963,
                   1.2934131736526946,
                   1.1497005988023954]

        """Linear Rg"""
        weights = [-0.2923943952307688,
                   0.0622230926274538,
                   3.3646279819599156,
                   1.2057896683992002,
                   0.1585585550751596,
                   1.501195097169039]

        # Empirical Selections of Weights:
        a = [1,
                   1,
                   1,
                   1,
                   1,
                   1]

        # Reload each models
        for detector in detectors:
            detector._reload()

        # Ask for an input of SQL semantics to process the scanning
        if sql is None:
            info = True
            print(">> Ready for joint scanning.")
            print(">> Enter the injected SQL semantics to evaluate")
            sql = str(input("> ").strip())
        # Preprocess the input of SQL semantics
        sql_tokens = nltk.word_tokenize(sql.strip())
        sql_vector = self.embedder.infer_vector(sql_tokens)

        # Take account of the weights for the prediction of models and compute an overall risk score, take an average to make sure of the result generalization;
        meanEvals = []
        epochNum = 3
        for i in range(epochNum):
            outcomes = []
            #ALL = []
            for detector in detectors:
                detectorOutcome = detector.simpleDetect(sql_vector)
                detectorWeight = weights[detectors.index(detector)]
                outcomes.append(detectorOutcome * detectorWeight)
                #ALL.append(detectorOutcome)
            meanEvals.append(sum(outcomes) / len(outcomes))
            #if i == 2:
                #print(ALL)
        meanEval = sum(meanEvals) / epochNum

        # Based on the weighted scanning report, mark the risk level of the input
        if meanEval >= 0.8:
            risk = "VULNERABILITY"
            print(R)
        elif meanEval >= 0.7:
            risk = "HIGH RISK"
            print(Y)
        elif meanEval >= 0.5:
            risk = "MEDIUM RISK"
            print(Y)
        else:
            risk = "LOW RISK"
            print(G)

        # If needed, print an indication message to report the risk to users
        if info:
            print(f"\n>> Detection result: {meanEval} - {risk} for SQL INJECTION \n(predicted by the weighted scanner depends on {len(detectors)} models)\n")
        #print(RESET) #todo
        return meanEval, risk

    def file(self):
        """
            Scans and evaluates each line in a log file for detecting SQL injection risks. This method is designed for
        a batch processing of many SQL semantics acquired by a website; The input data is assumed to be stored in a log
        file line by line;
        """
        # Output indication information to ask for a log file path input
        print(">> Ready for file-based joint scanning.")
        print(">> Enter your file path to scan and evaluate")
        filepath = str(input("> ").strip())

        # Prepare a report table for reporting the batch-based scanning outcomes
        recorder = PrettyTable(['Index', 'Source Code', 'Score', 'Risk Level'])
        fileEval = 0
        counter = 0
        redCounter, yellowCounter, greenCounter = 0, 0, 0
        try:
            # Report the risk level for each line with the corresponding colour and message output
            with open(filepath, 'r') as f:
                print(f">> Scanning File: {filepath}...")
                for (index, line) in enumerate(f):
                    counter += 1
                    print(f"\r* Checking line {index}")
                    lineEval, riskLevel = self.scan(line)
                    if float(lineEval[0]) >= 0.7:
                        color = R
                        redCounter += 1
                    elif float(lineEval[0]) >= 0.5:
                        color = Y
                        yellowCounter += 1
                    else:
                        color = G
                        greenCounter += 1
                    fileEval += lineEval
                    recorder.add_row([color + str(index), line, lineEval, riskLevel])
        # If filepath invalid, report the issue and stop the file scanning
        except FileNotFoundError:
            print(f">> FilePathError: '{filepath}' not found, please try again;\n")
            return
        print(f">> Scanning Accomplished.\n")
        print(f"\t\t * VULNERABILITY & HIGH RISK - {redCounter}/{counter} = {redCounter/counter}")
        print(f"\t\t * MEDIUM RISK - {yellowCounter}/{counter} = {yellowCounter/counter}")
        print(f"\t\t * LOW RISK - {greenCounter}/{counter} = {greenCounter/counter}")

        # Also compute and report an overall risk level based on all datalines contained in the log file
        size = len(recorder._rows)
        fileEval /= size
        if fileEval >= 0.8:
            risk = "VULNERABILITY"
        elif fileEval >= 0.7:
            risk = "HIGH RISK"
        elif fileEval >= 0.5:
            risk = "MEDIUM RISK"
        else:
            risk = "LOW RISK"
        print(f"\n>> Overall File Risk Score: {fileEval} - {risk} \n(predicted by the weighted file scanner over {size} lines of codes)\n")

        # Ask for the printing of the table with line-by-line risk detection outcomes
        print(">> Line-based result needed? [(y)es for printing]")
        ask = str(input("> ").strip().lower())
        if ask == "y" or ask == "yes":
            print(B)
            print(recorder)
            print(RESET)

    def analyze(self):
        """
            This is a developer function which is used to examine and compare the multi-classifier outcomes to the output
        of every single classifier and also the ground-truth labels, to research the performance practically and crate a
        formal log file locally.
        """
        # Output indication information to ask for a log file path input
        print(">> Ready for file-based joint scanning.")
        print(">> Enter your file path to scan and evaluate")
        testData = "weights/x.txt"
        y = []
        with open("weights/y.txt", 'r') as file:
            for line in file:
                # Remove newline character and save label
                y.append(line.strip())

        # Prepare a report table for reporting the batch-based scanning outcomes
        infos = []
        try:
            # Report the risk level for each line with the corresponding colour and message output
            with open(testData, 'r') as f:
                print(f">> Scanning File: {testData}...")
                for (index, line) in enumerate(f):
                    # Looping over each dataline to get the all-around scanning reports
                    lineEval, riskLevel = self.scan(line)
                    info = f"\nID=[{index}]: feature=[{line}], risk=[{riskLevel}], groundTruth=[{y[index]}]"
                    print(info)
                    infos.append(info)
        # If filepath invalid, report the issue and stop the file scanning
        except FileNotFoundError:
            print(f">> FilePathError: '{testData}' not found, please try again;\n")
            return
        print(f">> Scanning Accomplished.\n")

        # Output the analysis results to the file named 'analysis.log'
        with open('analysis.log', 'w') as f:
            for item in infos:
                f.write("%s\n" % item)


def web_scan(input_text):
    """
        Scans an input text for SQL injection risks, to be used in a web application;
     :return:
        - formatted_output, dict, a dictionary contains the risk level and score;
     """
    # Create an instant of the Interactor, process the scanning over the input semantics
    agent = Interactor()
    meanEval, risk = agent.scan(input_text, info=False)

    # Organize the detection outcomes as a dictionary and return
    formatted_output = {
        "risk": risk,
        "score": float(meanEval)  # Converting to float for JSON serialization
    }
    return formatted_output


if __name__ == '__main__':
    """ 
        Here is the main process of the interactive detector;
    """
    # Initialize the interactor detector and start by calling Interactor.help()
    agent = Interactor()
    agent.help(init=True)

    # Enter the interactive process; Take a command option input and provide corresponding services by calling methods
    while True:
        cmd = input("> ").lower().strip()
        if cmd == "help" or cmd == "h":
            agent.help(init=True)
        elif cmd == "detect" or cmd == "d":
            agent.detect()
            agent.help()
        elif cmd == "scan" or cmd == "s":
            agent.scan()
            agent.help()
        elif cmd == "file" or cmd == "f":
            agent.file()
            agent.help()
        elif cmd == "analyze" or cmd == "a":
            agent.analyze()
            agent.help()
        elif cmd == "rebuild" or cmd == "r":
            agent.rebuild()
            agent.help()
        # Enter the specific command to exit
        elif cmd == "exit" or cmd == "e":
            print(">> Have a good one!")
            exit()
        # If the input is invalid then give a response and continue the loop
        else:
            sys.stderr.write(">> Unknown Command, please review the instruction and try again\n")