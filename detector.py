import sys
import nltk
nltk.download('punkt')

from prettytable import PrettyTable
from gensim.models import Doc2Vec

from preprocessor import Preprocessor
from models.knn import KNNModel
from models.nb import NBModel
from models.logReg import LogRegModel
from models.svm import SVMModel
from models.dt import DTModel
from models.gbdt import GBDTModel


SELECTIONS = {
    1: "Logistic Regression",
    2: "Naive Bayes",
    3: "k-nearest Neighbor",
    4: "Support Vector Machine",
    5: "Decision Tree",
    6: "Gradient Boost Decision Tree"
}

CV = 3
EVAL = ('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy')

B = "\033[0;34;40m"     # BLUE
Y = "\033[0;33;40m"     # YELLOW
G = "\033[0;32;40m"     # GREEN
R = "\033[0;31;40m"     # RED
RESET = "\033[0m"       # COLOR RESET


class Interactor:
    def __init__(self):
        print("\n>> Initializing detector...")
        self.SELECT = 4
        self.detector = SVMModel(cv=CV, cvEval=EVAL)
        self.detector._reload()
        self.embedder = Doc2Vec.load("srcs/doc2vec.pkl")
        print(">> DONE.\n")

    def help(self, init=False):
        if init:
            print(">> Hi, this detector applies multiple ML models to check risks of SQL semantic inputs, you could")
        print(B + "* Enter <(r)ebuild> to rebuild a model from scratch (cover the pre-trained)")
        print("* Enter <(d)etect> to check a SQL input by a specific pretrained detector")
        print("* Enter <(s)can> to scan a SQL input with all pretrained detectors")
        print("* Enter <(f)ile> to scan a log file with all pretrained detectors")
        print("* Enter <(h)elp> to review the instruction page")
        print("* Enter <(e)xit> to exit")
        print(RESET)

    def detect(self):
        self.select()

        print(">> Enter your SQL semantics to test")
        sql = input("> ")
        sql_tokens = nltk.word_tokenize(sql.strip())
        sql_vector = self.embedder.infer_vector(sql_tokens)
        outcome = self.detector.simpleDetect(sql_vector)
        if outcome[0] == 0:
            risk = "HIGH SQL INJECTION RISK"
        else:
            risk = "LOW SQL INJECTION RISK"
        print(f"\n>> Detection result: {risk} \n(predicted by Model {self.SELECT} - {SELECTIONS[self.SELECT]})\n")

    def select(self):
        print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
        print(">> Enter an ID to change detector, you may have"
              "\n\t* 1=LogisticRegression;"
              "\n\t* 2=Naive Bayes;"
              "\n\t* 3=k-nearest Neighbors;"
              "\n\t* 4=Support Vector Machine;"
              "\n\t* 5=Decision Tree;"
              "\n\t* 6=Gradient Boost Decision Tree;")
        try:
            self.SELECT = int(input("> "))
            if self.SELECT == 0:
                pass
            elif self.SELECT == 1:
                self.detector = LogRegModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 2:
                self.detector = NBModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 3:
                self.detector = KNNModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 4:
                self.detector = SVMModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 5:
                self.detector = DTModel(cv=CV, cvEval=EVAL)
            elif self.SELECT == 6:
                self.detector = GBDTModel(cv=CV, cvEval=EVAL)
            else:
                raise
        except:
            sys.stderr.write("\n>> ModelSelectionError: Invalid model selection.")
            self.select()
            return
        self.detector._reload()
        print(">> Model reload successfully")

    def rebuild(self):
        while True:
            print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
            IN = input(">> Do you want to rebuild it? [(y)es for rebuilding] [(s)elect for switching model] \n> ").strip().lower()
            if IN == "yes" or IN == "y":
                print(f"* WARNING: This operation will cover the existing pre-training one;")
                IN2 = input(f">> Are you sure you want to rebuild Model {self.SELECT} - {SELECTIONS[self.SELECT]}? [(y)es to continue] [(n)o to cancel] \n> ")
                if IN2 == 'no' or IN2 == "n":
                    break
                print(f"\n>> Data Preprocessor Ready.")
                P = Preprocessor(dirPath="data/")
                P.process()
                print(f"\n>> Model Trainer Ready.")
                if self.SELECT == 1:
                    self.detector = LogRegModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 2:
                    self.detector = NBModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 3:
                    self.detector = KNNModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 4:
                    self.detector = SVMModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 5:
                    self.detector = DTModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                elif self.SELECT == 6:
                    self.detector = GBDTModel(cv=CV, cvEval=EVAL)
                    self.detector.classify(P.datasets_train, P.datasets_test, True)
                print(f"\n>> Model Rebuilt Successfully.")
                print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
                break
            elif IN == "select" or IN == "s":
                self.select()
            else:
                break

    def scan(self, sql=None, info=False):
        detectors = [LogRegModel(cv=CV, cvEval=EVAL),
                     NBModel(cv=CV, cvEval=EVAL),
                     KNNModel(cv=CV, cvEval=EVAL),
                     SVMModel(cv=CV, cvEval=EVAL),
                     DTModel(cv=CV, cvEval=EVAL),
                     GBDTModel(cv=CV, cvEval=EVAL)]
        weights = [1.25, 0.5, 1.25, 1.5, 0.5, 1]

        for detector in detectors:
            detector._reload()
        if sql is None:
            info = True
            print(">> Ready for joint scanning.")
            print(">> Enter the injected SQL semantics to evaluate")
            sql = str(input("> ").strip())
        sql_tokens = nltk.word_tokenize(sql.strip())
        sql_vector = self.embedder.infer_vector(sql_tokens)

        meanEvals = []
        epochNum = 3
        for i in range(epochNum):
            outcomes = []
            for detector in detectors:
                outcomes.append(detector.simpleDetect(sql_vector) * weights[detectors.index(detector)])
            meanEvals.append(sum(outcomes) / len(outcomes))
        meanEval = sum(meanEvals) / epochNum

        if meanEval >= 0.9:
            risk = "VERY HIGH RISK"
            print(R)
        elif meanEval >= 0.7:
            risk = "HIGH RISK"
            print(Y)
        elif meanEval >= 0.6:
            risk = "MEDIUM RISK"
            print(Y)
        elif meanEval >= 0.4:
            risk = "LOW RISK"
            print(G)
        else:
            risk = "VERY LOW RISK"
            print(G)
        if info:
            print(f"\n>> Detection result: {meanEval} - {risk} for SQL INJECTION \n(predicted by the weighted scanner depends on {len(detectors)} models)\n")
        print(RESET)
        return meanEval, risk

    def file(self):
        print(">> Ready for file-based joint scanning.")
        print(">> Enter your file path to scan and evaluate")
        filepath = str(input("> ").strip())

        recorder = PrettyTable(['Index', 'Source Code', 'Score', 'Risk Level'])
        fileEval = 0
        try:
            with open(filepath, 'r') as f:
                print(f">> Scanning File: {filepath}...")
                for (index, line) in enumerate(f):
                    print(f"\r* Checking line {index}")
                    lineEval, riskLevel = self.scan(line)
                    if float(lineEval[0]) >= 0.7:
                        color = R
                    elif float(lineEval[0]) >= 0.6:
                        color = Y
                    else:
                        color = G
                    fileEval += lineEval
                    recorder.add_row([color + str(index), line, lineEval, riskLevel])
        except FileNotFoundError:
            print(f">> FilePathError: '{filepath}' not found, please try again;\n")
            return
        print(f">> Scanning Accomplished.\n")

        size = len(recorder._rows)
        fileEval /= size
        if fileEval >= 0.9:
            risk = "VERY HIGH SQL INJECTION RISK"
        elif fileEval >= 0.7:
            risk = "HIGH SQL INJECTION RISK"
        elif fileEval >= 0.6:
            risk = "MEDIUM SQL INJECTION RISK"
        elif fileEval >= 0.4:
            risk = "LOW SQL INJECTION RISK"
        else:
            risk = "VERY LOW SQL INJECTION RISK"
        print(f"\n>> Overall File Risk Score: {fileEval} - {risk} \n(predicted by the weighted file scanner over {size} lines of codes)\n")

        print(">> Line-based result needed? [(y)es for printing]")
        ask = str(input("> ").strip().lower())
        if ask == "y" or ask == "yes":
            print(B)
            print(recorder)
            print(RESET)
            
def web_scan(input_text):
    agent = Interactor()
    meanEval, risk = agent.scan(input_text, info=False)

    formatted_output = {
        "risk": risk,
        "score": float(meanEval)  # Converting to float for JSON serialization
    }
    return formatted_output


if __name__ == '__main__':
    agent = Interactor()
    agent.help(init=True)

    while True:
        cmd = input("> ").lower().strip()
        if cmd == "help" or cmd == "h":
            agent.help(init=True)
        elif cmd == "detect" or cmd == "d":
            agent.detect()
            agent.help()
        elif cmd == "scan" or cmd == "s":
            agent.scan()
            agent.help()
        elif cmd == "file" or cmd == "f":
            agent.file()
            agent.help()
        elif cmd == "rebuild" or cmd == "r":
            agent.rebuild()
            agent.help()
        elif cmd == "exit" or cmd == "e":
            print(">> Have a good one!")
            exit()
        else:
            sys.stderr.write(">> Unknown Command, please review the instruction and try again\n")






