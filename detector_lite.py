import sys

import nltk
from gensim.models import Doc2Vec
from models.knn import KNNModel
from models.nb import NBModel
from models.logReg import LogRegModel
from models.svm import SVMModel


SELECTIONS = {
    0: "Baseline",
    1: "Logistic Regression",
    2: "Naive Bayes",
    3: "k-nearest Neighbor",
    4: "Support Vector Machine",
    5: "Fully-connected Neural Network",
    6: "RNN/LSTM"
}


class Interactor:
    def __init__(self):
        print("\n>> Initializing detector...")
        self.SELECT = 4
        self.HISTORY = {}
        self.detector = SVMModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy'))
        self.detector._reload()
        self.embedder = Doc2Vec.load("srcs/doc2vec.pkl")
        print(">> DONE.\n")

    def help(self, init=False):
        if init:
            print(">> Hi, this detector applies pre-trained models to check the SQL semantics input, you could")
        print("\t* Enter <(b)uild> to rebuild a model from scratch (retraining to replace the currents)")
        print("\t* Enter <(d)etect> to check risks combined with an SQL input by a specific pretrained detector")
        print("\t* Enter <(c)hange> to select a pretrained detector")
        print("\t* Enter <(s)can> to scan an SQL input with all pretrained detectors and form an overall report")
        print("\t* Enter <(h)elp> to review the instruction page")
        print("\t* Enter <(e)xit> to exit the process")


    def detect(self):
        print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
        print(">> Enter your SQL semantics to test")
        sql = input("> ")
        sql_tokens = nltk.word_tokenize(sql.strip())
        sql_vector = self.embedder.infer_vector(sql_tokens)
        outcome = self.detector.simpleDetect(sql_vector)
        if outcome[0] == 0:
            risk = "HIGH SQL INJECTION RISK"
        else:
            risk = "LOW SQL INJECTION RISK"
        print(f"\n>> Detection result: {risk} \n(predicted by Model {self.SELECT} - {SELECTIONS[self.SELECT]})\n")

    def select(self):
        print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")
        print(">> Enter an ID to change detector, you may have"
              "\n\t* 0=Baseline;"
              "\n\t* 1=LogisticRegression;"
              "\n\t* 2=Naive Bayes;"
              "\n\t* 3=k-nearest Neighbors;"
              "\n\t* 4=Support Vector Machine;"
              "\n\t* 5=FCN;"
              "\n\t* 6=RNN/LSTM")
        self.SELECT = int(input("> "))
        try:
            if self.SELECT == 0:
                pass
            elif self.SELECT == 1:
                self.detector = LogRegModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy'))
            elif self.SELECT == 2:
                self.detector = NBModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy'))
            elif self.SELECT == 3:
                self.detector = KNNModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy'))
            elif self.SELECT == 4:
                self.detector = SVMModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy'))
            elif self.SELECT == 5:
                pass
            elif self.SELECT == 6:
                pass
            else:
                raise
        except:
            sys.stderr.write("\n>> ModelSelectionError: Invalid model selection, try rebuilding first;")
            return
        self.detector._reload()
        print(">> Model reload successfully")
        print(f">> Current loaded detector: Model {self.SELECT} - {SELECTIONS[self.SELECT]}")

    def build(self):
        pass

    def scan(self):
        detectors = [LogRegModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy')),
                     NBModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy')),
                     KNNModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy')),
                     SVMModel(cv=3, cvEval=('neg_mean_squared_error', 'f1_micro', 'balanced_accuracy'))]
        weights = [1, 0.3, 1.35, 1.35]

        for detector in detectors:
            detector._reload()
        print(">> Ready for joint scanning.")
        print(">> Enter your SQL semantics to scan")
        sql = input("> ")
        sql_tokens = nltk.word_tokenize(sql.strip())
        sql_vector = self.embedder.infer_vector(sql_tokens)

        meanEvals = []
        epochNum = 3
        for i in range(epochNum):
            outcomes = []
            for detector in detectors:
                outcomes.append(detector.simpleDetect(sql_vector) * weights[detectors.index(detector)])
            meanEvals.append(sum(outcomes) / len(outcomes))
        meanEval = sum(meanEvals) / epochNum

        if meanEval >= 0.9:
            risk = "VERY HIGH SQL INJECTION RISK"
        elif meanEval >= 0.7:
            risk = "HIGH SQL INJECTION RISK"
        elif meanEval >= 0.6:
            risk = "MEDIUM SQL INJECTION RISK"
        elif meanEval >= 0.4:
            risk = "LOW SQL INJECTION RISK"
        else:
            risk = "VERY LOW SQL INJECTION RISK"
        print(f"\n>> Detection result: {meanEval} - {risk} \n(predicted by the weighted scanner depends on {len(detectors)} models)\n")


if __name__ == '__main__':
    agent = Interactor()
    agent.help(init=True)

    while True:
        cmd = input("> ").lower().strip()
        if cmd == "help" or cmd == "h":
            agent.help(init=True)
        elif cmd == "detect" or cmd == "d":
            agent.detect()
            agent.help()
        elif cmd == "scan" or cmd == "s":
            agent.scan()
            agent.help()
        elif cmd == "change" or cmd == "c":
            agent.select()
            agent.help()
        elif cmd == "build" or cmd == "b":
            agent.build()
            agent.help()
        elif cmd == "exit" or cmd == "e":
            print(">> Have a good one!")
            exit()
        else:
            print(">> Unknown Command, please review the instruction and try again")






