import numpy as np
import torch
from torch import nn
from torch.utils.data import DataLoader, TensorDataset
from sklearn.metrics import accuracy_score, f1_score, confusion_matrix, log_loss
from sklearn.metrics import f1_score
from sklearn.metrics import accuracy_score


class DeepNNModel:
    """
       Taking a Deep NN model initialized; Set parameters for the model learning process;
    :param
        - cv, int, the fold number for cross-validation;
        - cvEval, tuple, contains all evaluation benchmarks selected that will be used for performance analysis;
    """
    def __init__(self, input_dim, hidden_dim, output_dim):
        self.model = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, output_dim),
            nn.Softmax(dim=1)
        )
        self.criterion = nn.CrossEntropyLoss()
        self.optimizer = torch.optim.Adam(self.model.parameters())

    def _training(self, datasets_train: tuple, epochs=50):
        """
            This method is used to train the Deep NN model by taking cross-validations for each selection of the
        hyperparameters; The method will figure out the optimal choice by checking the F1-score;
        :param
            - datasets_train, tuple, training datasets for the model;
        """
        X_train = torch.tensor(datasets_train[0], dtype=torch.float32)
        y_train = torch.tensor(datasets_train[1], dtype=torch.long)
        train_data = TensorDataset(X_train, y_train)
        train_loader = DataLoader(dataset=train_data, batch_size=100, shuffle=True)

        for epoch in range(epochs):
            for inputs, targets in train_loader:
                outputs = self.model(inputs)
                loss = self.criterion(outputs, targets)
                self.optimizer.zero_grad()
                loss.backward()
                self.optimizer.step()

        self._store()

    def _store(self):
        """
            This method is used to store the best classifier model into a local file;
        """
        torch.save(self.model.state_dict(), 'srcs/dnn.pkl')

    def _reload(self):
        """
            This method is used to reload the pre-trained optimal classifier model from a local file;
        """
        self.model.load_state_dict(torch.load('srcs/dnn.pkl'))

    def _predict(self, datasets_test: tuple):
        """
            This method is used to predict the testing datasets and evaluate its performance;
        :param
            - datasets_test, tuple, testing datasets for the model;
            - doTraining, bool, whether the model has been trained before prediction, for different message indications;
        """
        X_test = torch.tensor(datasets_test[0], dtype=torch.float32)
        y_test = torch.tensor(datasets_test[1], dtype=torch.long).numpy()

        with torch.no_grad():
            outputs = self.model(X_test)
            _, predicted = torch.max(outputs.data, 1)
            predicted = predicted.numpy()
            test_accuracy = accuracy_score(y_test, predicted)
            test_f1_macro = f1_score(y_test, predicted, average='macro')
            test_f1_micro = f1_score(y_test, predicted, average='micro')
            tn, fp, fn, tp = confusion_matrix(y_test, predicted).ravel()

        results = (f"\n> Model of Deep Neural Network (DNN):"
                   f"\n\t* Test Accuracy --> Accuracy={test_accuracy}"
                   f"\n\t* Test F-score (Macro) --> F1 (Macro)={test_f1_macro}"
                   f"\n\t* Test F-score (Micro) --> F1 (Micro)={test_f1_micro}"
                   f"\n\t* True Positives (TP) --> TP={tp}"
                   f"\n\t* False Positives (FP) --> FP={fp}"
                   f"\n\t* True Negatives (TN) --> TN={tn}"
                   f"\n\t* False Negatives (FN) --> FN={fn}\n")
        print(results)

    def classify(self, datasets_train, datasets_test, doTraining=True):
        """
            This is a controller method that will automatically execute the model learning process. The parameter will
        determine the task of "training + prediction" (redoing the whole process) or "only prediction" (after reloading);
        :param
            - datasets_train, tuple, training datasets for the model;
            - datasets_test, tuple, testing datasets for the model;
            - doTraining, bool, whether to perform a training phase;
        """
        if doTraining:
            # Take the training process
            self._training(datasets_train=datasets_train)
        # Take the prediction process
        self._predict(datasets_test=datasets_test)

    def simpleDetect(self, sql):
        """
            A simple version for prediction designed for our quick-check detector; Performs a prediction for a
        single-line input;
        :param
            - sql, numpy.ndarray, the input data to predict;
        :return
            - predictions, numpy.ndarray, the prediction result for the input of SQL semantics.
        """
        sql = np.array(sql).reshape(1, -1)
        sql = torch.tensor(sql, dtype=torch.float32)
        with torch.no_grad():
            outputs = self.model(sql)
            _, predicted = torch.max(outputs.data, 1)
        return predicted.item()